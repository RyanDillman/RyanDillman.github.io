{"ast":null,"code":"/** @license React v16.6.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /* eslint-disable no-var */\n    // TODO: Use symbols?\n\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var IdlePriority = 4; // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000; // Never times out\n\n    var IDLE_PRIORITY = maxSigned31BitInt; // Callbacks are stored as a circular, doubly linked list.\n\n    var firstCallbackNode = null;\n    var currentPriorityLevel = NormalPriority;\n    var currentEventStartTime = -1;\n    var currentExpirationTime = -1; // This is set when a callback is being executed, to prevent re-entrancy.\n\n    var isExecutingCallback = false;\n    var isHostCallbackScheduled = false;\n    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n    var timeRemaining;\n\n    if (hasNativePerformanceNow) {\n      timeRemaining = function timeRemaining() {\n        if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n          // A higher priority callback was scheduled. Yield so we can switch to\n          // working on that.\n          return 0;\n        } // We assume that if we have a performance timer that the rAF callback\n        // gets a performance timer value. Not sure if this is always true.\n\n\n        var remaining = getFrameDeadline() - performance.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    } else {\n      timeRemaining = function timeRemaining() {\n        // Fallback to Date.now()\n        if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n          return 0;\n        }\n\n        var remaining = getFrameDeadline() - Date.now();\n        return remaining > 0 ? remaining : 0;\n      };\n    }\n\n    var deadlineObject = {\n      timeRemaining: timeRemaining,\n      didTimeout: false\n    };\n\n    function ensureHostCallbackIsScheduled() {\n      if (isExecutingCallback) {\n        // Don't schedule work yet; wait until the next time we yield.\n        return;\n      } // Schedule the host callback using the earliest expiration in the list.\n\n\n      var expirationTime = firstCallbackNode.expirationTime;\n\n      if (!isHostCallbackScheduled) {\n        isHostCallbackScheduled = true;\n      } else {\n        // Cancel the existing host callback.\n        cancelHostCallback();\n      }\n\n      _requestHostCallback(flushWork, expirationTime);\n    }\n\n    function flushFirstCallback() {\n      var flushedNode = firstCallbackNode; // Remove the node from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n\n      var next = firstCallbackNode.next;\n\n      if (firstCallbackNode === next) {\n        // This is the last callback in the list.\n        firstCallbackNode = null;\n        next = null;\n      } else {\n        var lastCallbackNode = firstCallbackNode.previous;\n        firstCallbackNode = lastCallbackNode.next = next;\n        next.previous = lastCallbackNode;\n      }\n\n      flushedNode.next = flushedNode.previous = null; // Now it's safe to call the callback.\n\n      var callback = flushedNode.callback;\n      var expirationTime = flushedNode.expirationTime;\n      var priorityLevel = flushedNode.priorityLevel;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousExpirationTime = currentExpirationTime;\n      currentPriorityLevel = priorityLevel;\n      currentExpirationTime = expirationTime;\n      var continuationCallback;\n\n      try {\n        continuationCallback = callback(deadlineObject);\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentExpirationTime = previousExpirationTime;\n      } // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n\n\n      if (typeof continuationCallback === 'function') {\n        var continuationNode = {\n          callback: continuationCallback,\n          priorityLevel: priorityLevel,\n          expirationTime: expirationTime,\n          next: null,\n          previous: null\n        }; // Insert the new callback into the list, sorted by its expiration. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal expiration instead\n        // of after.\n\n        if (firstCallbackNode === null) {\n          // This is the first callback in the list.\n          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n        } else {\n          var nextAfterContinuation = null;\n          var node = firstCallbackNode;\n\n          do {\n            if (node.expirationTime >= expirationTime) {\n              // This callback expires at or after the continuation. We will insert\n              // the continuation *before* this callback.\n              nextAfterContinuation = node;\n              break;\n            }\n\n            node = node.next;\n          } while (node !== firstCallbackNode);\n\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority callback was found, which means the new\n            // callback is the lowest priority callback in the list.\n            nextAfterContinuation = firstCallbackNode;\n          } else if (nextAfterContinuation === firstCallbackNode) {\n            // The new callback is the highest priority callback in the list.\n            firstCallbackNode = continuationNode;\n            ensureHostCallbackIsScheduled();\n          }\n\n          var previous = nextAfterContinuation.previous;\n          previous.next = nextAfterContinuation.previous = continuationNode;\n          continuationNode.next = nextAfterContinuation;\n          continuationNode.previous = previous;\n        }\n      }\n    }\n\n    function flushImmediateWork() {\n      if ( // Confirm we've exited the outer most event handler\n      currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n        isExecutingCallback = true;\n        deadlineObject.didTimeout = true;\n\n        try {\n          do {\n            flushFirstCallback();\n          } while ( // Keep flushing until there are no more immediate callbacks\n          firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n        } finally {\n          isExecutingCallback = false;\n\n          if (firstCallbackNode !== null) {\n            // There's still work remaining. Request another callback.\n            ensureHostCallbackIsScheduled();\n          } else {\n            isHostCallbackScheduled = false;\n          }\n        }\n      }\n    }\n\n    function flushWork(didTimeout) {\n      isExecutingCallback = true;\n      deadlineObject.didTimeout = didTimeout;\n\n      try {\n        if (didTimeout) {\n          // Flush all the expired callbacks without yielding.\n          while (firstCallbackNode !== null) {\n            // Read the current time. Flush all the callbacks that expire at or\n            // earlier than that time. Then read the current time again and repeat.\n            // This optimizes for as few performance.now calls as possible.\n            var currentTime = exports.unstable_now();\n\n            if (firstCallbackNode.expirationTime <= currentTime) {\n              do {\n                flushFirstCallback();\n              } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n\n              continue;\n            }\n\n            break;\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstCallbackNode !== null) {\n            do {\n              flushFirstCallback();\n            } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n          }\n        }\n      } finally {\n        isExecutingCallback = false;\n\n        if (firstCallbackNode !== null) {\n          // There's still work remaining. Request another callback.\n          ensureHostCallbackIsScheduled();\n        } else {\n          isHostCallbackScheduled = false;\n        } // Before exiting, flush all the immediate work that was scheduled.\n\n\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case IdlePriority:\n          break;\n\n        default:\n          priorityLevel = NormalPriority;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousEventStartTime = currentEventStartTime;\n      currentPriorityLevel = priorityLevel;\n      currentEventStartTime = exports.unstable_now();\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled.\n\n        flushImmediateWork();\n      }\n    }\n\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        var previousEventStartTime = currentEventStartTime;\n        currentPriorityLevel = parentPriorityLevel;\n        currentEventStartTime = exports.unstable_now();\n\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n          currentEventStartTime = previousEventStartTime;\n          flushImmediateWork();\n        }\n      };\n    }\n\n    function unstable_scheduleCallback(callback, deprecated_options) {\n      var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n      var expirationTime;\n\n      if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n        // FIXME: Remove this branch once we lift expiration times out of React.\n        expirationTime = startTime + deprecated_options.timeout;\n      } else {\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n            break;\n\n          case UserBlockingPriority:\n            expirationTime = startTime + USER_BLOCKING_PRIORITY;\n            break;\n\n          case IdlePriority:\n            expirationTime = startTime + IDLE_PRIORITY;\n            break;\n\n          case NormalPriority:\n          default:\n            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n        }\n      }\n\n      var newNode = {\n        callback: callback,\n        priorityLevel: currentPriorityLevel,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      }; // Insert the new callback into the list, ordered first by expiration, then\n      // by insertion. So the new callback is inserted any other callback with\n      // equal expiration.\n\n      if (firstCallbackNode === null) {\n        // This is the first callback in the list.\n        firstCallbackNode = newNode.next = newNode.previous = newNode;\n        ensureHostCallbackIsScheduled();\n      } else {\n        var next = null;\n        var node = firstCallbackNode;\n\n        do {\n          if (node.expirationTime > expirationTime) {\n            // The new callback expires before this one.\n            next = node;\n            break;\n          }\n\n          node = node.next;\n        } while (node !== firstCallbackNode);\n\n        if (next === null) {\n          // No callback with a later expiration was found, which means the new\n          // callback has the latest expiration in the list.\n          next = firstCallbackNode;\n        } else if (next === firstCallbackNode) {\n          // The new callback has the earliest expiration in the entire list.\n          firstCallbackNode = newNode;\n          ensureHostCallbackIsScheduled();\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newNode;\n        newNode.next = next;\n        newNode.previous = previous;\n      }\n\n      return newNode;\n    }\n\n    function unstable_cancelCallback(callbackNode) {\n      var next = callbackNode.next;\n\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n\n      if (next === callbackNode) {\n        // This is the only scheduled callback. Clear the list.\n        firstCallbackNode = null;\n      } else {\n        // Remove the callback from its position in the list.\n        if (callbackNode === firstCallbackNode) {\n          firstCallbackNode = next;\n        }\n\n        var previous = callbackNode.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      callbackNode.next = callbackNode.previous = null;\n    }\n\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    } // The remaining code is essentially a polyfill for requestIdleCallback. It\n    // works by scheduling a requestAnimationFrame, storing the time for the start\n    // of the frame, then scheduling a postMessage which gets scheduled after paint.\n    // Within the postMessage handler do as much work as possible until time + frame\n    // rate. By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n    // We capture a local reference to any global, in case it gets polyfilled after\n    // this module is initially evaluated. We want to be using a\n    // consistent implementation.\n\n\n    var localDate = Date; // This initialization code may run even on server environments if a component\n    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n    // have setTimeout or clearTimeout. However, we always expect them to be defined\n    // on the client. https://github.com/facebook/react/pull/13088\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined; // We don't expect either of these to necessarily be defined, but we will error\n    // later if they are missing on the client.\n\n    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\n    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined; // requestAnimationFrame does not run when the tab is in the background. If\n    // we're backgrounded we prefer for that work to happen so that the page\n    // continues to load in the background. So we also schedule a 'setTimeout' as\n    // a fallback.\n    // TODO: Need a better heuristic for backgrounded work.\n\n    var ANIMATION_FRAME_TIMEOUT = 100;\n    var rAFID;\n    var rAFTimeoutID;\n\n    var requestAnimationFrameWithTimeout = function requestAnimationFrameWithTimeout(callback) {\n      // schedule rAF and also a setTimeout\n      rAFID = localRequestAnimationFrame(function (timestamp) {\n        // cancel the setTimeout\n        localClearTimeout(rAFTimeoutID);\n        callback(timestamp);\n      });\n      rAFTimeoutID = localSetTimeout(function () {\n        // cancel the requestAnimationFrame\n        localCancelAnimationFrame(rAFID);\n        callback(exports.unstable_now());\n      }, ANIMATION_FRAME_TIMEOUT);\n    };\n\n    if (hasNativePerformanceNow) {\n      var Performance = performance;\n\n      exports.unstable_now = function () {\n        return Performance.now();\n      };\n    } else {\n      exports.unstable_now = function () {\n        return localDate.now();\n      };\n    }\n\n    var _requestHostCallback;\n\n    var cancelHostCallback;\n    var getFrameDeadline;\n\n    if (typeof window !== 'undefined' && window._schedMock) {\n      // Dynamic injection, only for testing purposes.\n      var impl = window._schedMock;\n      _requestHostCallback = impl[0];\n      cancelHostCallback = impl[1];\n      getFrameDeadline = impl[2];\n    } else if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive\n    // implementation using setTimeout.\n    typeof window === 'undefined' || // \"addEventListener\" might not be available on the window object\n    // if this is a mocked \"window\" object. So we need to validate that too.\n    typeof window.addEventListener !== 'function') {\n      var _callback = null;\n\n      var _currentTime = -1;\n\n      var _flushCallback = function _flushCallback(didTimeout, ms) {\n        if (_callback !== null) {\n          var cb = _callback;\n          _callback = null;\n\n          try {\n            _currentTime = ms;\n            cb(didTimeout);\n          } finally {\n            _currentTime = -1;\n          }\n        }\n      };\n\n      _requestHostCallback = function requestHostCallback(cb, ms) {\n        if (_currentTime !== -1) {\n          // Protect against re-entrancy.\n          setTimeout(_requestHostCallback, 0, cb, ms);\n        } else {\n          _callback = cb;\n          setTimeout(_flushCallback, ms, true, ms);\n          setTimeout(_flushCallback, maxSigned31BitInt, false, maxSigned31BitInt);\n        }\n      };\n\n      cancelHostCallback = function cancelHostCallback() {\n        _callback = null;\n      };\n\n      getFrameDeadline = function getFrameDeadline() {\n        return Infinity;\n      };\n\n      exports.unstable_now = function () {\n        return _currentTime === -1 ? 0 : _currentTime;\n      };\n    } else {\n      if (typeof console !== 'undefined') {\n        // TODO: Remove fb.me link\n        if (typeof localRequestAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n\n        if (typeof localCancelAnimationFrame !== 'function') {\n          console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n        }\n      }\n\n      var scheduledHostCallback = null;\n      var isMessageEventScheduled = false;\n      var timeoutTime = -1;\n      var isAnimationFrameScheduled = false;\n      var isFlushingHostCallback = false;\n      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n\n      getFrameDeadline = function getFrameDeadline() {\n        return frameDeadline;\n      }; // We use the postMessage trick to defer idle work until after the repaint.\n\n\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n\n      var idleTick = function idleTick(event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n\n        isMessageEventScheduled = false;\n        var prevScheduledCallback = scheduledHostCallback;\n        var prevTimeoutTime = timeoutTime;\n        scheduledHostCallback = null;\n        timeoutTime = -1;\n        var currentTime = exports.unstable_now();\n        var didTimeout = false;\n\n        if (frameDeadline - currentTime <= 0) {\n          // There's no time left in this idle period. Check if the callback has\n          // a timeout and whether it's been exceeded.\n          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n            // Exceeded the timeout. Invoke the callback even though there's no\n            // time left.\n            didTimeout = true;\n          } else {\n            // No timeout.\n            if (!isAnimationFrameScheduled) {\n              // Schedule another animation callback so we retry later.\n              isAnimationFrameScheduled = true;\n              requestAnimationFrameWithTimeout(animationTick);\n            } // Exit without invoking the callback.\n\n\n            scheduledHostCallback = prevScheduledCallback;\n            timeoutTime = prevTimeoutTime;\n            return;\n          }\n        }\n\n        if (prevScheduledCallback !== null) {\n          isFlushingHostCallback = true;\n\n          try {\n            prevScheduledCallback(didTimeout);\n          } finally {\n            isFlushingHostCallback = false;\n          }\n        }\n      }; // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n\n\n      window.addEventListener('message', idleTick, false);\n\n      var animationTick = function animationTick(rafTime) {\n        if (scheduledHostCallback !== null) {\n          // Eagerly schedule the next animation callback at the beginning of the\n          // frame. If the scheduler queue is not empty at the end of the frame, it\n          // will continue flushing inside that callback. If the queue *is* empty,\n          // then it will exit immediately. Posting the callback at the start of the\n          // frame ensures it's fired within the earliest possible frame. If we\n          // waited until the end of the frame to post the callback, we risk the\n          // browser skipping a frame and not firing the callback until the frame\n          // after that.\n          requestAnimationFrameWithTimeout(animationTick);\n        } else {\n          // No pending work. Exit.\n          isAnimationFrameScheduled = false;\n          return;\n        }\n\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame time gets lower than 8, it is probably a bug.\n            nextFrameTime = 8;\n          } // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n\n\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n\n        frameDeadline = rafTime + activeFrameTime;\n\n        if (!isMessageEventScheduled) {\n          isMessageEventScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n      };\n\n      _requestHostCallback = function _requestHostCallback(callback, absoluteTimeout) {\n        scheduledHostCallback = callback;\n        timeoutTime = absoluteTimeout;\n\n        if (isFlushingHostCallback || absoluteTimeout < 0) {\n          // Don't wait for the next frame. Continue working ASAP, in a new event.\n          window.postMessage(messageKey, '*');\n        } else if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n      };\n\n      cancelHostCallback = function cancelHostCallback() {\n        scheduledHostCallback = null;\n        isMessageEventScheduled = false;\n        timeoutTime = -1;\n      };\n    }\n\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","ImmediatePriority","UserBlockingPriority","NormalPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstCallbackNode","currentPriorityLevel","currentEventStartTime","currentExpirationTime","isExecutingCallback","isHostCallbackScheduled","hasNativePerformanceNow","performance","now","timeRemaining","expirationTime","remaining","getFrameDeadline","Date","deadlineObject","didTimeout","ensureHostCallbackIsScheduled","cancelHostCallback","requestHostCallback","flushWork","flushFirstCallback","flushedNode","next","lastCallbackNode","previous","callback","priorityLevel","previousPriorityLevel","previousExpirationTime","continuationCallback","continuationNode","nextAfterContinuation","node","flushImmediateWork","currentTime","unstable_now","unstable_runWithPriority","eventHandler","previousEventStartTime","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_scheduleCallback","deprecated_options","startTime","timeout","newNode","unstable_cancelCallback","callbackNode","unstable_getCurrentPriorityLevel","localDate","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","ANIMATION_FRAME_TIMEOUT","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","Performance","window","_schedMock","impl","addEventListener","_callback","_currentTime","_flushCallback","ms","cb","Infinity","console","error","scheduledHostCallback","isMessageEventScheduled","timeoutTime","isAnimationFrameScheduled","isFlushingHostCallback","frameDeadline","previousFrameTime","activeFrameTime","messageKey","Math","random","toString","slice","idleTick","event","source","data","prevScheduledCallback","prevTimeoutTime","animationTick","rafTime","nextFrameTime","postMessage","absoluteTimeout","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority"],"sources":["/home/ryan/RyanDillman.github.io/node_modules/scheduler/cjs/scheduler.development.js"],"sourcesContent":["/** @license React v16.6.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar IdlePriority = 4;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar currentPriorityLevel = NormalPriority;\nvar currentEventStartTime = -1;\nvar currentExpirationTime = -1;\n\n// This is set when a callback is being executed, to prevent re-entrancy.\nvar isExecutingCallback = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar timeRemaining;\nif (hasNativePerformanceNow) {\n  timeRemaining = function () {\n    if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n      // A higher priority callback was scheduled. Yield so we can switch to\n      // working on that.\n      return 0;\n    }\n    // We assume that if we have a performance timer that the rAF callback\n    // gets a performance timer value. Not sure if this is always true.\n    var remaining = getFrameDeadline() - performance.now();\n    return remaining > 0 ? remaining : 0;\n  };\n} else {\n  timeRemaining = function () {\n    // Fallback to Date.now()\n    if (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime) {\n      return 0;\n    }\n    var remaining = getFrameDeadline() - Date.now();\n    return remaining > 0 ? remaining : 0;\n  };\n}\n\nvar deadlineObject = {\n  timeRemaining: timeRemaining,\n  didTimeout: false\n};\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isExecutingCallback) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest expiration in the list.\n  var expirationTime = firstCallbackNode.expirationTime;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelHostCallback();\n  }\n  requestHostCallback(flushWork, expirationTime);\n}\n\nfunction flushFirstCallback() {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var lastCallbackNode = firstCallbackNode.previous;\n    firstCallbackNode = lastCallbackNode.next = next;\n    next.previous = lastCallbackNode;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  var expirationTime = flushedNode.expirationTime;\n  var priorityLevel = flushedNode.priorityLevel;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousExpirationTime = currentExpirationTime;\n  currentPriorityLevel = priorityLevel;\n  currentExpirationTime = expirationTime;\n  var continuationCallback;\n  try {\n    continuationCallback = callback(deadlineObject);\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentExpirationTime = previousExpirationTime;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var continuationNode = {\n      callback: continuationCallback,\n      priorityLevel: priorityLevel,\n      expirationTime: expirationTime,\n      next: null,\n      previous: null\n    };\n\n    // Insert the new callback into the list, sorted by its expiration. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal expiration instead\n    // of after.\n    if (firstCallbackNode === null) {\n      // This is the first callback in the list.\n      firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;\n    } else {\n      var nextAfterContinuation = null;\n      var node = firstCallbackNode;\n      do {\n        if (node.expirationTime >= expirationTime) {\n          // This callback expires at or after the continuation. We will insert\n          // the continuation *before* this callback.\n          nextAfterContinuation = node;\n          break;\n        }\n        node = node.next;\n      } while (node !== firstCallbackNode);\n\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority callback was found, which means the new\n        // callback is the lowest priority callback in the list.\n        nextAfterContinuation = firstCallbackNode;\n      } else if (nextAfterContinuation === firstCallbackNode) {\n        // The new callback is the highest priority callback in the list.\n        firstCallbackNode = continuationNode;\n        ensureHostCallbackIsScheduled();\n      }\n\n      var previous = nextAfterContinuation.previous;\n      previous.next = nextAfterContinuation.previous = continuationNode;\n      continuationNode.next = nextAfterContinuation;\n      continuationNode.previous = previous;\n    }\n  }\n}\n\nfunction flushImmediateWork() {\n  if (\n  // Confirm we've exited the outer most event handler\n  currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {\n    isExecutingCallback = true;\n    deadlineObject.didTimeout = true;\n    try {\n      do {\n        flushFirstCallback();\n      } while (\n      // Keep flushing until there are no more immediate callbacks\n      firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);\n    } finally {\n      isExecutingCallback = false;\n      if (firstCallbackNode !== null) {\n        // There's still work remaining. Request another callback.\n        ensureHostCallbackIsScheduled();\n      } else {\n        isHostCallbackScheduled = false;\n      }\n    }\n  }\n}\n\nfunction flushWork(didTimeout) {\n  isExecutingCallback = true;\n  deadlineObject.didTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the expired callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.expirationTime <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n      }\n    }\n  } finally {\n    isExecutingCallback = false;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled();\n    } else {\n      isHostCallbackScheduled = false;\n    }\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousEventStartTime = currentEventStartTime;\n  currentPriorityLevel = priorityLevel;\n  currentEventStartTime = exports.unstable_now();\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentEventStartTime = previousEventStartTime;\n\n    // Before exiting, flush all the immediate work that was scheduled.\n    flushImmediateWork();\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    var previousEventStartTime = currentEventStartTime;\n    currentPriorityLevel = parentPriorityLevel;\n    currentEventStartTime = exports.unstable_now();\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n      currentEventStartTime = previousEventStartTime;\n      flushImmediateWork();\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(callback, deprecated_options) {\n  var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();\n\n  var expirationTime;\n  if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {\n    // FIXME: Remove this branch once we lift expiration times out of React.\n    expirationTime = startTime + deprecated_options.timeout;\n  } else {\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;\n        break;\n      case UserBlockingPriority:\n        expirationTime = startTime + USER_BLOCKING_PRIORITY;\n        break;\n      case IdlePriority:\n        expirationTime = startTime + IDLE_PRIORITY;\n        break;\n      case NormalPriority:\n      default:\n        expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;\n    }\n  }\n\n  var newNode = {\n    callback: callback,\n    priorityLevel: currentPriorityLevel,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, ordered first by expiration, then\n  // by insertion. So the new callback is inserted any other callback with\n  // equal expiration.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled();\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.expirationTime > expirationTime) {\n        // The new callback expires before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later expiration was found, which means the new\n      // callback has the latest expiration in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest expiration in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled();\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelCallback(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestHostCallback;\nvar cancelHostCallback;\nvar getFrameDeadline;\n\nif (typeof window !== 'undefined' && window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestHostCallback = impl[0];\n  cancelHostCallback = impl[1];\n  getFrameDeadline = impl[2];\n} else if (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// \"addEventListener\" might not be available on the window object\n// if this is a mocked \"window\" object. So we need to validate that too.\ntypeof window.addEventListener !== 'function') {\n  var _callback = null;\n  var _currentTime = -1;\n  var _flushCallback = function (didTimeout, ms) {\n    if (_callback !== null) {\n      var cb = _callback;\n      _callback = null;\n      try {\n        _currentTime = ms;\n        cb(didTimeout);\n      } finally {\n        _currentTime = -1;\n      }\n    }\n  };\n  requestHostCallback = function (cb, ms) {\n    if (_currentTime !== -1) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb, ms);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, ms, true, ms);\n      setTimeout(_flushCallback, maxSigned31BitInt, false, maxSigned31BitInt);\n    }\n  };\n  cancelHostCallback = function () {\n    _callback = null;\n  };\n  getFrameDeadline = function () {\n    return Infinity;\n  };\n  exports.unstable_now = function () {\n    return _currentTime === -1 ? 0 : _currentTime;\n  };\n} else {\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledHostCallback = null;\n  var isMessageEventScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isFlushingHostCallback = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  getFrameDeadline = function () {\n    return frameDeadline;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isMessageEventScheduled = false;\n\n    var prevScheduledCallback = scheduledHostCallback;\n    var prevTimeoutTime = timeoutTime;\n    scheduledHostCallback = null;\n    timeoutTime = -1;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        scheduledHostCallback = prevScheduledCallback;\n        timeoutTime = prevTimeoutTime;\n        return;\n      }\n    }\n\n    if (prevScheduledCallback !== null) {\n      isFlushingHostCallback = true;\n      try {\n        prevScheduledCallback(didTimeout);\n      } finally {\n        isFlushingHostCallback = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    if (scheduledHostCallback !== null) {\n      // Eagerly schedule the next animation callback at the beginning of the\n      // frame. If the scheduler queue is not empty at the end of the frame, it\n      // will continue flushing inside that callback. If the queue *is* empty,\n      // then it will exit immediately. Posting the callback at the start of the\n      // frame ensures it's fired within the earliest possible frame. If we\n      // waited until the end of the frame to post the callback, we risk the\n      // browser skipping a frame and not firing the callback until the frame\n      // after that.\n      requestAnimationFrameWithTimeout(animationTick);\n    } else {\n      // No pending work. Exit.\n      isAnimationFrameScheduled = false;\n      return;\n    }\n\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If the calculated frame time gets lower than 8, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isMessageEventScheduled) {\n      isMessageEventScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestHostCallback = function (callback, absoluteTimeout) {\n    scheduledHostCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isFlushingHostCallback || absoluteTimeout < 0) {\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelHostCallback = function () {\n    scheduledHostCallback = null;\n    isMessageEventScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}